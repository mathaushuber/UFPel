PARSER_BEGIN(Karloff)
import java.io.*;
import java.util.ArrayList;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.util.Scanner;

/**
 * Ponto de entrada para o parser. Esta classe gera código Java com base na entrada
 * analisada da linguagem Karloff.
 */
public class Karloff {
    public static void main(String[] args) throws ParseException, IOException {
        Karloff parser = new Karloff(new FileInputStream(args[0]));
        String inputFileName = new File(args[0]).getName();
        KarloffTree tree = parser.Karloff(inputFileName);
  
        // Verifica e cria o diretório se não existir
        File directory = new File("../GeneratedOutputs/");
        if (!directory.exists()){
            directory.mkdirs();
        }
        
        String baseName = inputFileName.substring(0, inputFileName.lastIndexOf('.'));
        String outputFileName = baseName + "_output_generator.java";
        File outputFile = new File(directory.getPath() + "/" + outputFileName);
  
        // Verificar se o arquivo já existe
        if (outputFile.exists()) {
            Scanner scanner = new Scanner(System.in);
            System.out.println("Já existe um arquivo com esse nome na pasta. Deseja sobrescrevê-lo? (Sim/Nao)");
  
            while (true) { // Um loop para continuar perguntando até receber uma resposta válida
                String userResponse = scanner.nextLine();
  
                if ("Sim".equalsIgnoreCase(userResponse)) {
                    break; 
                } else if ("Nao".equalsIgnoreCase(userResponse)) {
                    System.out.println("Operação cancelada pelo usuário.");
                    scanner.close();
                    return; 
                } else {
                    System.out.println("Resposta inválida. Por favor, responda com 'Sim' ou 'Nao'.");
                }
            }
            scanner.close();
        }
  
        FileWriter file = new FileWriter(outputFile);
        PrintWriter print = new PrintWriter(file);
        print.printf(tree.toString());
        print.close();
        file.close();
        System.out.println(tree);
    }
  }

/**
 * Representa a função principal na linguagem Karloff. Ela consiste em declarações de variáveis
 * e uma sequência de comandos a serem executados.
 */
class KarloffMain{
    ArrayList<VariableDeclaration> variableDeclaration;
    CommandSequence commandSequence;

    KarloffMain(ArrayList<VariableDeclaration> variableDeclaration, CommandSequence commandSequence){
        this.variableDeclaration = variableDeclaration;
        this.commandSequence = commandSequence;
    }

    @Override
    public String toString() {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("public static void main(String[] args) {\n");
        for (VariableDeclaration decVar : this.variableDeclaration) {
            stringBuilder.append(decVar).append("\n");
        }
        return stringBuilder.append(this.commandSequence).append("}\n").toString();
    }
}

/**
 * Representa a árvore de sintaxe abstrata completa de um programa Karloff. Isso inclui
 * o método principal e quaisquer outras funções definidas no programa.
 */
class KarloffTree{
    KarloffMain main;
    FunctionList lf;
    String inputFileName;

    KarloffTree(KarloffMain main, String inputFileName){
        this.main = main;
        this.inputFileName = inputFileName;
    }
    
    KarloffTree(KarloffMain main, FunctionList lf, String inputFileName){
        this.main = main;
        this.lf = lf;
        this.inputFileName = inputFileName;
    }    

    @Override
    public String toString() {
        String baseName = this.inputFileName.substring(0, this.inputFileName.lastIndexOf('.'));
        String outputFileName = baseName + "_output_generator";
        return "import java.util.Scanner;\npublic class " + outputFileName + "{\n\n"
        + this.main + (this.lf == null ? "" : "\n" + this.lf) + "\n}\n";
    }
}

/**
 * Representa uma única declaração de variável na linguagem Karloff, incluindo o tipo da variável
 * e seu identificador.
 */
class VariableDeclaration{
    TokenId tokenId;
    VariableType variableType;

    VariableDeclaration(VariableType variableType, TokenId tokenId){
        this.variableType = variableType;
        this.tokenId = tokenId;
    }

    @Override
    public String toString() {
        if (this.variableType != null && this.tokenId != null)
            return this.variableType + " " + this.tokenId + ";";
        else
            return "";
    }
}


/**
 * Representa o tipo de uma variável na linguagem Karloff. Isso pode ser inteiro ou booleano.
 */
class VariableType{
    String tipo;

    VariableType(String tipo){
        this.tipo = tipo;
    }

    @Override
    public String toString() {
        switch (this.tipo){
            case "integer":
                return "int";
            case "bool":
                return "boolean";
            default:
                return "";
        }
    }
}

/**
 * Representa uma sequência de comandos na linguagem Karloff. Esta sequência pode fazer parte do
 * método principal ou de qualquer outra função.
 */
class CommandSequence{
    ArrayList<Com> comandos;

    CommandSequence(ArrayList<Com> comandos){
        this.comandos = comandos;
    }

    @Override
    public String toString() {
        StringBuilder stringBuilder = new StringBuilder();
        for (Com com : this.comandos) {
            stringBuilder.append(com).append("\n");
        }
        return stringBuilder.toString();
    }
}

/**
 * Classe base para todos os comandos na linguagem Karloff.
 */
class Com{}
class Assignment extends Com{
    Expression exp;
    TokenId tokenId;

    Assignment(Expression exp, TokenId tokenId){
        this.exp = exp;
        this.tokenId = tokenId;
    }

    @Override
    public String toString() {
        return this.tokenId + " = " + this.exp + ";";
    }
}
// As seguintes classes representam comandos específicos na linguagem Karloff:
class ChamadaFuncCom extends Com{
    TokenId tokenId;
    ExpressionList expList;

    ChamadaFuncCom(TokenId tokenId, ExpressionList expList){
        this.tokenId = tokenId;
        this.expList = expList;
    }

    @Override
    public String toString() {
        if (this.expList == null) return this.tokenId + "()" + ";";
        return this.tokenId + "(" + this.expList + ")" + ";";
    }
}
class ConditionalStatement extends Com{
    Expression exp;
    CommandSequence commandSequence;

    ConditionalStatement(Expression exp, CommandSequence commandSequence){
        this.exp = exp;
        this.commandSequence = commandSequence;
    }

    @Override
    public String toString() {
        return "if (" + this.exp + ") {\n" + this.commandSequence + "}";
    }
}
class WhileLoop extends Com{
    Expression exp;
    CommandSequence commandSequence;

    WhileLoop(Expression exp, CommandSequence commandSequence){
        this.exp = exp;
        this.commandSequence = commandSequence;
    }

    @Override
    public String toString() {
        return "while (" + this.exp + ") {\n" + this.commandSequence + "}";
    }
}
class RepeatLoop extends Com{
    Expression exp;
    CommandSequence commandSequence;

    RepeatLoop(Expression exp, CommandSequence commandSequence){
        this.exp = exp;
        this.commandSequence = commandSequence;
    }

    @Override
    public String toString() {
        return "do {\n" + this.commandSequence + "} while (" + this.exp + ");";
    }
}
class ReturnStatement extends Com{
    Expression exp;

    ReturnStatement(Expression exp){
        this.exp = exp;
    }

    @Override
    public String toString() {
        return "return " + this.exp + ";";
    }
}
class Saida extends Com{
    Expression exp;

    Saida(Expression exp){
        this.exp = exp;
    }

    @Override
    public String toString() {
        return "System.out.println(" + this.exp + ");";
    }
}
class Scan extends Com{
    TokenId tokenId;
    private static int counter = 0;

    Scan(TokenId tokenId){
        this.tokenId = tokenId;
    }

    @Override
    public String toString() {
        StringBuilder stringBuilder = new StringBuilder();
        if (counter == 0) stringBuilder.append("Scanner scan = new Scanner(System.in);\n");
        stringBuilder.append(this.tokenId).append(" = scan.nextInt();\nscan.nextLine();\n");
        counter++;
        return stringBuilder.toString();
    }
}

/**
 * Representa uma expressão na linguagem Karloff. Uma expressão pode ser uma
 * operação matemática, um valor, uma variável ou uma chamada de função.
 */
class Expression{}
// As seguintes classes representam expressões específicas na linguagem Karloff:
class ExpressionRecursion extends Expression{
    Expression exp1, exp2;
    Operation op;

    ExpressionRecursion(Expression exp1, Expression exp2, Operation op){
        this.exp1 = exp1;
        this.exp2 = exp2;
        this.op = op;
    }

    @Override
    public String toString() {
        return "(" + this.exp1 + " " + this.op + " " + this.exp2 + ")";
    }
}
class Fator extends Expression{}
class TokenId extends Fator {
    String var;

    TokenId(String var){
        this.var = var;
    }

    @Override
    public String toString() {
        return this.var;
    }
}
class TokenNum extends Fator {
    Integer num;

    TokenNum(Integer num){
        this.num = num;
    }

    @Override
    public String toString() {
        return this.num.toString();
    }
}
class FunctionCallFactor extends Fator{
    TokenId tokenId;
    ExpressionList expList;

    FunctionCallFactor(TokenId tokenId, ExpressionList expList){
        this.tokenId = tokenId;
        this.expList = expList;
    }

    @Override
    public String toString() {
        if (this.expList == null) return this.tokenId + "()";
        return this.tokenId + "(" + this.expList + ")";
    }
}
class VF extends Fator{
    String vf;

    VF(String vf){
        this.vf = vf;
    }

    @Override
    public String toString() {
        return this.vf;
    }
}

/**
 * Representa um operador na linguagem Karloff.
 */
class Operation{
     String op;

     Operation(String op){
         this.op = op;
     }

     @Override
     public String toString() {
         return this.op;
     }
}

/**
 * Representa uma lista de expressões na linguagem Karloff. Isso é usado
 * em chamadas de função para representar os argumentos passados para a função.
 */
class ExpressionList{
    ArrayList<Expression> expressoes;

    ExpressionList(ArrayList<Expression> expressoes){
        this.expressoes = expressoes;
    }

    @Override
     public String toString() {
        if (this.expressoes.size() == 1) return expressoes.get(0).toString();
        StringBuilder stringBuilder = new StringBuilder();
        for (Expression exp : this.expressoes) {
            stringBuilder.append(exp).append(", ");
        }
        return stringBuilder.toString();
    }
}

/**
 * Representa uma única definição de função na linguagem Karloff.
 */
class FunctionDefinition{
    TokenId tokenId;
    VariableType variableType;
    ArgumentsList listaArgumentos;
    ArrayList<VariableDeclaration> variableDeclaration;
    CommandSequence commandSequence;

    FunctionDefinition(TokenId tokenId, VariableType variableType, ArgumentsList listaArgumentos, ArrayList<VariableDeclaration> variableDeclaration, CommandSequence commandSequence){
            this.tokenId = tokenId;
            this.variableType = variableType;
            this.listaArgumentos = listaArgumentos;
            this.variableDeclaration = variableDeclaration;
            this.commandSequence = commandSequence;
    }

    @Override
     public String toString() {
        StringBuilder stringBuilder = new StringBuilder("public static " + this.variableType + " " + this.tokenId + "(" + this.listaArgumentos + ") {\n");
        for (VariableDeclaration decVar : this.variableDeclaration) {
            stringBuilder.append(decVar).append("\n");
        }
        stringBuilder.append(commandSequence).append("}\n");
        return stringBuilder.toString();
    }
}

/**
 * Representa uma lista de funções na linguagem Karloff.
 */
class FunctionList{
    ArrayList<FunctionDefinition> funcoes;

    FunctionList(ArrayList<FunctionDefinition> funcoes){
        this.funcoes = funcoes;
    }

    @Override
     public String toString() {
        if (this.funcoes.size() == 1) return this.funcoes.get(0).toString();
        StringBuilder stringBuilder = new StringBuilder();
        for (FunctionDefinition func : this.funcoes) {
            stringBuilder.append(func.toString()).append("\n");
        }
        return stringBuilder.toString();
    }
}

/**
 * Representa um único argumento para uma função na linguagem Karloff.
 */
class Argument{
    TokenId tokenId;
    VariableType variableType;

    Argument(TokenId tokenId, VariableType variableType){
        this.tokenId = tokenId;
        this.variableType = variableType;
    }

    @Override
     public String toString() {
        return this.variableType + " " + this.tokenId;
    }
}

/**
 * Representa uma lista de argumentos para uma função na linguagem Karloff.
 */
class ArgumentsList{
    ArrayList<Argument> argumentos;

    ArgumentsList(ArrayList<Argument> argumentos){
        this.argumentos = argumentos;
    }

    @Override
     public String toString() {
        if (this.argumentos.size() == 1) return this.argumentos.get(0).toString();
        StringBuilder stringBuilder = new StringBuilder();
        for (Argument arg : this.argumentos) {
            stringBuilder.append(arg).append(", ");
        }
        return stringBuilder.toString();
    }
}


PARSER_END(Karloff)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
  <MAIN: "main">
| <ACHAVES: "{">
| <FCHAVES: "}">
| <VOID: "void">
| <APARENTESES: "(">
| <FPARENTESES: ")">
| <NEWVAR: "newVar">
| <PONTOVIRGULA: ";">
| <INTEIRO: "integer">
| <BOOLEANO: "bool">
| <ATRIB: "=">
| <IF: "if">
| <THEN: "then">
| <WHILE: "while">
| <REPEAT: "repeat">
| <UNTIL: "until">
| <RETURN: "return">
| <SOUT: "System.output">
| <SREADINT: "System.readint">
| <TRUE: "true">
| <FALSE: "false">
| <SOMA: "+">
| <SUB: "-">
| <MULT: "*">
| <DIV: "/">
| <AND: "&">
| <OR: "|">
| <MENOR: "<">
| <MAIOR: ">">
| <MENORIGUAL: "<=">
| <MAIORIGUAL: ">=">
| <IGUAL: "==">
| <VIRGULA: ",">
| <FUNC: "func">
}

TOKEN :
{
  <NUM : (["0"-"9"])+>
 |< ID: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"])*>

}

// KARLOFF → MAIN FUNC?
KarloffTree Karloff (String inputFileName) :
{KarloffMain main = null; FunctionList lf = null;}
{
    main=Main() (lf=Func())?
    <EOF>
    {return lf == null ? new KarloffTree(main, inputFileName) : new KarloffTree(main, lf, inputFileName);}
}

// MAIN → "void" "main" "(" ")" "{" VARDECL SEQCOMANDOS "}"
KarloffMain Main () :
{ArrayList<VariableDeclaration> varDec = null; CommandSequence seqCom = null;}
{
    <VOID> <MAIN> <APARENTESES> <FPARENTESES> <ACHAVES> varDec=Vardecl() seqCom=SeqComandos() <FCHAVES>
    {return new KarloffMain(varDec, seqCom);}
}

// VARDECL → VARDECL "newVar" TIPO TOKEN_id ";" | vazio
ArrayList<VariableDeclaration> Vardecl () :
{Token t = null; VariableType variableType = null; ArrayList<VariableDeclaration> ldv = new ArrayList();}
{
    (<NEWVAR> variableType=Tipo() t=<ID> <PONTOVIRGULA> {ldv.add(new VariableDeclaration(variableType, new TokenId(t.image)));})*
    {return ldv;}
}

// TIPO → "integer" | "bool"
VariableType Tipo () :
{VariableType variableType = null;}
{
    (
        <INTEIRO> {variableType = new VariableType("integer");}
        | <BOOLEANO> {variableType = new VariableType("bool");}
    )
    {return variableType;}
}

// SEQCOMANDOS → SEQCOMANDOS COMANDO | vazio
CommandSequence SeqComandos () :
{Com c = null; ArrayList<Com> comandos = new ArrayList();}
{
    (c=Comando() {comandos.add(c);})*
    {return new CommandSequence(comandos);}
}


// COMANDO → TOKEN_id COMANDO’
// | "if" "(" EXP ")" "then" "{" SEQCOMANDOS "}"  ";"
// | "while" "(" EXP ")" "{" SEQCOMANDOS "}"  ";"
// | "repeat" "{" SEQCOMANDOS "}" "until" "(" EXP ")"  ";"
// | "return" EXP  ";"
// | "System.output" "(" EXP ")"  ";"
Com Comando () :
{Token t = null; TokenId tokenId = null; CommandSequence seqCom = null;
Expression e = null; Com result = null; Com comL = null;}
{
    (
        t=<ID> comL=Comando_(new TokenId(t.image)) {result = comL;}
        | <IF> <APARENTESES> e=Exp() <FPARENTESES> <THEN> <ACHAVES> seqCom=SeqComandos() <FCHAVES> <PONTOVIRGULA> {result = new ConditionalStatement(e, seqCom);}
        | <WHILE> <APARENTESES> e=Exp() <FPARENTESES> <ACHAVES> seqCom=SeqComandos() <FCHAVES> <PONTOVIRGULA> {result = new WhileLoop(e, seqCom);}
        | <REPEAT> <ACHAVES> seqCom=SeqComandos() <FCHAVES> <UNTIL> <APARENTESES> e=Exp() <FPARENTESES> <PONTOVIRGULA> {result = new RepeatLoop(e, seqCom);}
        | <RETURN> e=Exp() <PONTOVIRGULA> {result = new ReturnStatement(e);}
        | <SOUT> <APARENTESES> e=Exp() <FPARENTESES> <PONTOVIRGULA> {result = new Saida(e);}
    )

    {return result;}
}

// COMANDO’ → "=" COMANDO’’ | "(" LISTAEXP? ")"  ";"
Com Comando_ (TokenId t) :
{Com result = null; Com comLL = null; ExpressionList l = null;}
{
    (
        <ATRIB> comLL=Comando__(t) {result = comLL;}
        | <APARENTESES> (l=ListaExp())? <FPARENTESES> <PONTOVIRGULA> {result = new ChamadaFuncCom(t, l);}
    )
    {return result;}
}

// COMANDO’’ → EXP ";" | "System.readint" "(" ")" ";"
Com Comando__ (TokenId t) :
{Com result = null; Expression e = null;}
{
    (
        e=Exp() <PONTOVIRGULA> {result = new Assignment(e, t);}
        | <SREADINT> <APARENTESES> <FPARENTESES> <PONTOVIRGULA> {result = new Scan(t);}
    )
    {return result;}
}

//EXP →  "(" EXP OP EXP ")" | FATOR
Expression Exp () :
{Expression e1 = null; Expression e2 = null; Operation op = null; Expression result = null; Fator f = null;}
{
    (
        <APARENTESES> e1=Exp() op=Op() e2=Exp() <FPARENTESES> {result = new ExpressionRecursion(e1, e2, op);}
        | f=Fator() {result = f;}
    )
    {return result;}
}

//FATOR →  TOKEN_id FATOR’| TOKEN_numliteral | "true" | "false"
Fator Fator () :
{Fator result = null; Fator fatorL = null; Token t = null; TokenId tokenId = null; TokenNum TokenNum = null;}
{
    (
        t=<ID> fatorL=Fator_(new TokenId(t.image)) {result = fatorL;}
        | t=<NUM> {result = new TokenNum(Integer.parseInt(t.image));}
        | <TRUE> {result = new VF("true");}
        | <FALSE> {result = new VF("false");}
    )
    {return result;}
}

//FATOR’ →  "(" LISTAEXP? ")" | vazio
Fator Fator_ (TokenId tokenId) :
{ExpressionList le = null; Token t = null;}
{
    (t=<APARENTESES> (le=ListaExp())? <FPARENTESES>)? {return t == null ? tokenId : new FunctionCallFactor(tokenId, le);}
}

//OP →  "+" | "-" | "*" | "/" | "&" | "|" | "<" | ">" | "=="
Operation Op () :
{Operation result = null;}
{
    (
        <SOMA> {result = new Operation("+");}
        | <SUB> {result = new Operation("-");}
        | <MULT> {result = new Operation("*");}
        | <DIV> {result = new Operation("/");}
        | <AND> {result = new Operation("&");}
        | <OR> {result = new Operation("|");}
        | <MENOR> {result = new Operation("<");}
        | <MENORIGUAL> {result = new Operation("<=");}
        | <MAIORIGUAL> {result = new Operation(">=");}
        | <MAIOR> {result = new Operation(">");}
        | <IGUAL> {result = new Operation("==");}
    )
    {return result;}
}

//LISTAEXP → EXP | LISTAEXP "," EXP
ExpressionList ListaExp () :
{Expression e = null; ArrayList<Expression> lista = new ArrayList();}
{
    e=Exp() {lista.add(e);} (<VIRGULA> e=Exp() {lista.add(e);})*
    {return new ExpressionList(lista);}
}

//FUNC → FUNC "func" TIPO TOKEN_id "(" LISTAARG? ")" "{" VARDECL SEQCOMANDOS "}"
//        | "func" TIPO TOKEN_id "(" LISTAARG? ")" "{" VARDECL SEQCOMANDOS "}"
FunctionList Func () :
{VariableType variableType = null; ArgumentsList la = null; ArrayList<FunctionDefinition> funcoes = new ArrayList();
ArrayList<VariableDeclaration> variableDeclaration = null; CommandSequence commandSequence = null;
Token t = null; TokenId tokenId = null;}
{
    (<FUNC> variableType=Tipo() t=<ID> <APARENTESES> (la=ListaArg())? <FPARENTESES> <ACHAVES> variableDeclaration=Vardecl() commandSequence=SeqComandos() <FCHAVES> {funcoes.add(new FunctionDefinition(new TokenId(t.image), variableType, la, variableDeclaration, commandSequence));})+
    {return new FunctionList(funcoes);}
}


//LISTAARG → TIPO TOKEN_id | LISTAARG "," TIPO TOKEN_id
ArgumentsList ListaArg () :
{Token t = null; VariableType variableType = null; TokenId tokenId = null;
ArgumentsList la = null; Argument arg = null; ArrayList<Argument> args = new ArrayList();}
{
    variableType=Tipo() t=<ID> {args.add(new Argument(new TokenId(t.image), variableType));} (<VIRGULA> variableType=Tipo() t=<ID> {args.add(new Argument(new TokenId(t.image), variableType));})*
    {return new ArgumentsList(args);}
}